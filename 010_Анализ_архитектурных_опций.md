# Анализ архитектурных опций

## Стиль системы/декомпозиция

**Подход: <u>Доменно-ориентированные микросервисы</u>**

**Обоснование:** Четкие границы ответственности доменов и возможность независимых релизов, что быстро позволит развивать социальные функции, интеграции с устройствами, персонализацию, эксперименты с промо-акциями. Масштабируемость под большие объемы (глобальные челленджи, соревнования, миллионы пользователей). Поддержка multi-cloud.

**Отклоненные опции:**
1. **Модульный монолит**. Быстрый старт MVP, четкие границы, но узкий для глобального масштаба, сложно эффективно масштабировать по частям, ограничение роста. В монолите сложнее реализовать изоляцию и сегментацию данных по регионам, усложняется контроль над потоками персональных данных.
2. **SOA/ESB**. Рассматривалась, т.к. используется для интеграции разнородных систем, упрощения взаимодействия между сервисами, поддержки корпоративных процессов. Отклонена из-за избыточной связность, риска «бутылочного горлышка», высокого времени вывода новых фич, зависимость от команды сопровождения ESB. ESB обычно разворачивается в одном дата-центре/облаке, сложен для глобального multi-cloud и требует ручной поддержки.

## Взаимодействие между доменами

**Подход: <u>Event-driven + REST</u>** 

**Обоснование:** Event-driven позволяет управлять асинхронно большим объемом событий  типа  обновления ленты новостей, рассылка уведомлений, запуск промо-акций, обработка данных от устройств и интеграций, обеспечивает слабую связность между доменати. REST для синхронных запросов данных, для слабо нагруженных синхронных и latency-critical сценариев.

**Отклоненные опции:**
1. **Только REST**. Прост в реализации и поддержке, подходит для синхронных запросов и хорошо поддерживается большинством языков и фреймворков. Но деградация производительности и доступности системы в пиковые моменты. Многие сценарии требуют событийной архитектуры. Плохо масштабируется на сложные интеграционные сценарии, где нужно уведомлять десятки/сотни потребителей о событии.

## Хранение данных

**Подход: <u>Отдельные БД. Разные типы БД в зависимости от задач домена</u>**

**Обоснование:**  Независимое масштабирование по доменам, целевые SLO в зависимости от сенариев и данных, меньшие операционные риски, гибкость эволюции (можно улучшать один домен, не ломая остальные): 
- Реляционная база данных для тех доменов, в которых требуется строгие требования к целостности, транзакционности, поддержка сложных связей, проверка уникальности: данные профиля пользователя, регистрация, заказы, корзины. 
- TSDB (База данных временных рядов) для хранение данных о тренировках, показателях датчиков (время, пульс, скорость, маршруты), событий активности пользователей. 
- Graph DB: связи между пользователями, группами, подписки, лента новостей, рекомендации друзей. 
- Vector DB: поиск похожих товаров, пользователей, маршрутов, персонализированные рекомендации.

**Отклоненные опции:** 
1. **Единая реляционная БД**. Несоответствие нагрузкам и моделям данных, не тянет граф для выстраивания социальных взаимодейтсвий и тайм-серии для тренировок.  Горизонтальное масштабирование сложно и дорого. Разные домены будут конкурировать за одни и те же ресурсы.
2. **Единая NoSQL**. Профиль, заказы,платежи требуют строгих ACID гарантий, сложных транзакций. Чтобы обобщить NoSQL под все потребности, необходимо предварительно проецировать данные под каждый запрос, множить представления и поддерживать их консистентность, это сложно и хрупко.

## Развертывание

**Подход: <u>Multi-cloud: primary+secondary по доменам, multi-region внутри</u>**

**Обоснование:** Соответствует ландшафту компании, управляемая сложность и затраты. Для каждого домена выбираем основное облако (primary) и держим резерв (secondary) в другом облаке. Внутри primary развертывание в нескольких регионах (multi-region) с автоматическим failover на уровне регионов. Закрывает требования высокой доступности, низкой латентности, регионализации данных, снижения рисков и совместимости с уже существующим мультиоблачным ландшафтом.
 
**Отклоненные опции:**
1. **Одино облако** противоречит практике и ландшафту компании
2. **Полный актив-актив кросс-облака** слишком сложен и дорог. Постоянный кросс-облачный трафик (данные/реплика/health). Кросс-облачная криптография, ротации, аудит. Полный актив-актив между облаками технически возможно, но TCO (совокупная стоимость владения), сложность наблюдаемости и затраты на контроль целлостности данных неоправданны.

## Языки программирования микросервисов

**Подход:**
- **Java** для доменов с высокой бизнес-логикой, транзакциями (e-commerce, профиль)
- **Go (Golang)** для сервисов с большим количеством асинхронных/сетевых операций (тренировки, уведомления)
- **Python** для ML/AI, рекомендательные движки
- **Node.js (TypeScript)** для BFF/GraphQL слоев, API Gateway, интеграции с UI/мобильными клиентами

**Обоснование:**
- **Java**
 - Лидер индустрии для сложных, транзакционных сервисов
 - Богатая экосистема, зрелые библиотеки для безопасности, интеграций, мониторинга
 - Широкая экспертиза и поддержка в корпоративных командах, легко найти специалистов
 - Поддержка полной мультиоблачности

- **Go (Golang)**
 - Высокая производительность при низком потреблении ресурсов
 - Поддержка асинхронных паттернов
 - Простое развертывание

- **Python**
 - Распорстранно принятый тандарт для ML/AI, аналитики
 - Огромное количество библиотек для анализа данных, машинного обучения, работы с API
 - Быстрый прототипинг и интеграция с другими сервисами

- **Node.js (TypeScript)**
 - Идеален для BFF, GraphQL, API Gateway. Высокая скорость разработки, много библиотек для работы с HTTP, JSON, WebSockets
 - Легкая интеграция с фронтендом, унификация моделей данных между фронтом и бэком

**Отклоненные опции:**
1. **C#/.NET** зрелая платформа, отличная поддержка для бизнес-логики, современная экосистема, но мало решений для мультиоблака, меньше специалистов на рынке для мультиоблачной среды 
2. **PHP/Ruby** хороши для монолитов и веба, но не для high-load, асинхронных микросервисов, слабая поддержка concurrency и стриминга, меньше зрелых библиотек для event-driven и инфраструктурных задач

## Инфраструктура и развертывание

**Подход: <u>Kubernetes плюс serverless для отдельных задач</u>**

**Обоснование:** Kubernetes (K8s) позволяет быстро масштабировать сервисы горизонтально, запускать новые экземпляры сервисов в зависимости от нагрузки. Поддержка multi-cloud и multi-region развертывания. Serverless как дополнение используется для поддержки ETL, ML-задач, event-driven функций, где важна быстрая реакция на события без поддержки always-on инфраструктуры.

**Отклоненные опции:**
1. **Bare Metal/On-premises** полный контроль, потенциальная экономия на долгом горизонте, независимость от облаков, но требует больших капитальных затрат и больших команд SRE, не соответствует стратегии multi-cloud и быстрой эволюции
2.  **Docker Swarm/Nomad** альтернативные решения для оркестрации контейнеров, но меньше зрелости и поддержки по сравнению с Kubernetes, ограниченные возможности для масштабных и распределенных систем, слабее поддержка в публичных облаках

## Аутентификация и авторизация. Шифрование данных

**Подход и Обоснование:**
- **Шифрование**
 - Cloud KMS/HSM используются нативные сервисы управления ключами каждого облачного провайдера
 - Transparent Data Encryption (TDE) включается на уровне БД для RDBMS/NoSQL обеспечивает автоматическое шифрование данных без изменений в приложении
 - Object Storage Encryption для защиты данных в хранилищах файлов и медиа
 - TLS 1.2/1.3 все внешние и внутренние API, брокеры событий, подключения к БД работают исключительно через TLS с современными алгоритмами шифрования и обязательной проверкой сертификатов
 - mTLS (Mutual TLS) используется для внутренних микросервисных коммуникаций, что обеспечивает двухстороннюю аутентификацию сервисов друг с другом
 - HSTS должно быть включено на публичных эндпоинтах для защиты от атак типа «downgrade» и man-in-the-middle
- **Аутентификация и авторизация**
 -  OAuth 2.0 для авторизации клиентов (мобильные, веб, внешние интеграции)
 -  OpenID Connect (OIDC) надстройка для аутентификации пользователей с поддержкой SSO, social login, MFA
 -  JWT (JSON Web Token) основной формат для передачи идентификационных данных между сервисами
 -  RBAC (Role-Based) назначение ролей на уровне сервисов, API, ресурсов, обеспечивает управляетмость
 -  ABAC (Attribute-Based) поддержка гибких политик доступа по атрибутам пользователя, географии, времени, состоянию сессии
 -  SCIM для централизованного управления пользовательскими доступами и группами, интеграция с корпоративными каталогами
 -  MFA (Multi-Factor Authentication) для критичных сценариев доступ к профилю, платежам, управлению согласиями
- **Управление секретами и ключами**
 -  Все API-ключи, пароли, токены только в зашифрованных секрет-хранилищах, с аудитом и автоматической ротацией
 -  Kubernetes Secrets для runtime переменных, интеграция с облачными секрет-хранилищами, автоматическая подгрузка и обновление в подах
 -  Политика регулярной смены ключей, автоматическое заведение новых токенов и отзыв устаревших/скомпрометированных

**Отклоненные опции:**
1. **Без шифрования** невозможен для современных требований безопасности и комплаенса
2. **Собственные крипто-библиотеки** выше риск ошибок, сложнее сертификация, нельзя доверять кастомным решениям для хранения ключей
3. **Локальные файлы для секретов** не защищены от компрометации, не поддерживают автоматическую ротацию и аудит, сложно отследить утечку
4. **Отказ от отсутствия шифрования в транспортном уровне** передача данных без TLS (HTTP, plain TCP) легко перехватывается во внутренней и облачной сети
5. **Basic Auth** легко подвержен атакам, не поддерживает ротацию/отзыв токенов и слабые механизмы контроля сессий
6. **Session-based (cookie)** плохо подходят для микросервисной архитектуры, сложно масштабировать, сложно поддерживать stateless API и mobile-first сценарии
7. **Cамописные протоколы авторизации** риск ошибок в реализации, отсутствие поддержки стандартных OAuth2/OIDC, невозможность интеграции с внешними системами (SSO, social login)

## Безопасность данных, API и сервисов

**Подход и Обоснование:**
 -  **API Gateway с termination TLS** все внешние вызовы проходят через шлюз с валидацией сертификатов, rate limiting, WAF
 -  **Web Application Firewall (WAF)** на всех публичных сервисах для защиты от XSS, SQLi, DDoS, бот-атак
 -  **DDoS Protection** использование облачных сервисов для автоматической фильтрации подозрительного трафика
 -  **Data residency и geo-fencing** персональные данные физически хранятся только в разрешенных регионах (GDPR, локальные законы)
 -  **Токенизация и маскирование PII (Personally Identifiable Information).** Внутренние сервисы получают только псевдонимизированные данные, реальные идентификаторы доступны строго ограниченным сервисам
 -  **Аудит и журналирование всех действий с чувствительными данными, интеграция с SIEM**
 -  **Zero Trust**. mTLS, сервисные идентичности, минимальные права доступа, отсутствие implicit trust даже внутри кластера

**Отклоненные опции:**
1. **Без API Gateway/шлюза** невозможно реализовать аудит и централизованный контроль безопасности. Каждый сервис должен дублировать логику аутентификации и безопасности, что ведет к ошибкам и рассинхронизации политик
2. **Ручное управление ACL на уровне VPC/Firewall** ACL/FW полезны, но не способны выявлять сложные веб-атаки (XSS, CSRF, SQLi, bot-атаки). Нет гибкой настройки, нет защиты на уровне приложений. Управление становится слишком сложным и не масштабируется при большом количестве сервисов
3. **Доверенные провайдеры каналов** не защищает от распределенных атак на уровне приложения. Только облачные DDoS-сервисы способны оперативно масштабироваться и срезать трафик до приложения

## Аудит и мониторинг

**Подход и Обоснование:**
- **OpenTelemetry** открытый стандарт для сбора метрик, логов и трассировок, поддерживаемый всеми крупными языками (Java, Go, Python, Node.js и др.) и платформами. Обеспечивает стандартизацию сбора данных, поддержка multi-cloud. Позволяет реализовать SLO/SLA/SLI на уровне сервисов, доменов и бизнес-операций
- **Prometheus** распространенно принятый стандарт сбора метрик в Kubernetes, гибкий язык запросов (PromQL), open-source и независимость от облака
- **Grafana** поддерживает подключение к Prometheus позволяет строить интерактивные дашборды для разных ролей, настройка алертов по метрикам и логам, open-source и поддержка multi-cloud
- **Централизованный SIEM** агрегирует логи, события, алерты с приложений, облаков, инфраструктуры. Быстрое построение цепочек событий, анализ инцидентов, подготовка отчетов для аудита. Построение правил и моделей для выявления вторжений, DDoS, аномальных действий с PII, подозрительных логинов

**Отклоненные опции:**
1. **Облако-специфичные стеки** фрагментация метрик и логов, сложно вести сквозной мониторинг, тяжелый мультиоблачный аудит
2. **Только ручной лог-анализ**  не масштабируется, не обеспечивает real-time обнаружение инцидентов
3. **Собственные решения для аудита и мониторинга** дорого в поддержке, низкая надежность, высокая цена внедрения новых метрик

## DevOps/CI/CD

**Подход и Обоснование:**
- **GitHub Actions, GitLab CI, CircleCI** все три инструмента позволяют строить сложные пайплайны для любых языков и платформ, поддерживают параллельные сборки, автоматическую интеграцию с репозиториями кода, не требуют отдельного обслуживания CI/CD-инфраструктуры особенно для старта проектов
- **ArgoCD или Flux** автоматизация доставки изменений в Kubernetes кластеры строго через Git, что повышает безопасность и предсказуемость деплоев, поддержка multi-cloud и multi-cluster, возможность легко откатить релиз, видеть историю изменений и работать через визуальные дашборды
- **Helm** распространенно принятый стандарт пакетирования и управления деплоем для Kubernetes, позволяет параметризовать деплои под разные окружения (dev, test, prod), регионы и облака, интеграция с ArgoCD или Flux
- **Policy-as-Code (Open Policy Agent (OPA) или Kyverno)** все изменения инфраструктуры и приложений проходят автоматическую проверку на соответствие политикам (запрет открытых сервисов, гарантия наличия аннотаций, секретов, ограничений ресурсов), обеспечивает гиибкое и автоматическое применение политик безопасности

**Отклоненные опции:**
1. **Jenkins-only** требует больше ручного обслуживания, сложная поддержка в мультикластерной/мультиоблачной среде
2. **Ручные деплои**  не масштабируются, не позволяют быстро и безопасно выкатывать фичи, нет контроля версий развертываний
3. **Cloud native CI/CD** сложности с мультиоблачной стратегией, ограниченность интеграций с внешними и гибридными решениями
